Haskellプログラミングガイドライン
=================================

これは
http://www.haskell.org/haskellwiki/Programming_guidelines
の翻訳である。

(前書き省略)

GHC開発チームによる、彼らの内部コーディング標準に関する解説が
http://hackage.haskell.org/trac/ghc/wiki/WorkingConventions
にある。

構文とスタイルに関する短いコメントが
http://research.microsoft.com/~simonpj/papers/haskell-retrospective/
にもある。

以下にて、プログラム文書化、ファイル形式、命名規約、よいプログラミング慣習について述べる。
（MattのC/C++ Programming Guidelines and the Linux kernel coding styleを翻案したものである。）

文書化
------

注釈は利用者視点の用語で記述する。
専門用語は使わない。それはコードが述べることだ。

注釈は正しい綴りと文法で、句読点を伴う完全な文により記述する。（英語の場合）

「一般論として、コードが*どう*するのかでなく*何を*するのかを注釈が述べるようにする。
また、関数本体の中に注釈を入れることは避ける。
関数の一部分に注釈を入れたくなるほど関数が複雑ならば、
するべきことは…」（関数の分割だ。

輸出する全ての関数とデータ型の上にhaddockコメントを置く。
`haddock`がそれを読み込めることを確認する。

ファイル形式
------------

全てのHaskellソースファイルは以下の形式のhaddockヘッダで開始する。
(文芸的形式の場合を除く？）

```haskell
{- |
Module      :  <ファイル名もしくは$Header$として自動置き換えさせる>
Description :  <本文ページに表示される短い説明（オプション）>
Copyright   :  (c) <著者または組織>
License     :  <ライセンス>

Maintainer  :  <メールアドレス>
Stability   :  unstable | experimental | provisional | stable | frozen
Portability :  portable | non-portable (<理由>)

<モジュール説明は行の1文字目から開始する>
-}
```

コンパイラ向けのプラグマ（`{-# LANGUAGE CPP #-}`など）はこのヘッダより上に置いてよい。
次にくる階層的モジュール名はファイル名と合っている必要がある。

（他のものからヘッダをコピペした場合）記述がモジュールのものであること確認する。
メンテナとして自分のメールアドレスを入れる。

移植性のある（Haskell98準拠の）コードを書くようにする。
多引数型クラス(multi-parameter type class)と
関数的依存(?)(functinal dependencies)などを用いるコードは
"```non-portable (MPTC with FD)```"となる。

`$Header$`は自動的に展開される。

（ぬるい読者を考慮して）行の折り返しを避けるために、行は80文字以下にする。75以下が望ましい。

行末に空白文字を残してはならない。

タブは全て空白文字に展開する。これは誤った展開を避けるためである。
（また、タブが8文字相当でない環境で異なって表示される事も避ける。）
`~/.emacs`に次のように書いておく。

```elisp
(custom-set-variables '(indent-tabs-mode nil))
```

ファイルの最後の文字は改行にする。
Solarisでは(?)
そうでない場合に警告され、また改行のない最終行は無視される恐れがある。
（改行のない"`#endif`"など）
通常emacsは最後に改行を入れるように問い合わせてくる。

ファイル形式を確認するためには
http://hackage.haskell.org/package/scan
が利用できる。

モジュール全体は長すぎないようにする。（およそ400行）

命名慣習
========

Haskellの型名は大文字で開始し、関数名は小文字で開始する。
中置きの識別子は避ける。
記号による中置き識別子の定義はライブラリの作者のみ行ってよい。

（行末に中置き識別子"`\`"があると`cpp`プリプロセッサが誤動作する。）

名前（特に大域的なもの）は説明的であるべきである。
名前が長くなるときは大文字小文字の交ぜ書き（キャメルケース camelCase）で書く。
（ただし、`thisVariableIsATemporaryCounter`よりは`tmp`の方がよい。）

また、標準ライブラリでは、複数の単語からなる関数名にはcamelCaseが用いられている。
同様に、型クラスや構成子名はStudlyCapsが用いられている。

我々のコードの一部では、長い識別子に（不要な大文字をなくせる）下線が用いられている。
これは要求仕様書に現れるハイフン付きの名前をよく反映する。
また、そのような名前は、必要なら予約語との衝突を避けるために
（一貫性のある）接頭辞もしくは接尾辞を付加して、camlCase名に書き直すべきである。
しかしながら、接頭辞や接尾辞を繰り返す代わりに、
修正付き輸入(qualified import)と名前を検討するとよい。
(qualified nameかな)

プログラミングのよい習慣
------------------------

「関数は短く、なめらかで、一つのことだけをするべきである。
（ISO/ANSIの画面サイズ80x24の）1画面か2画面に収まり、
一つのことだけをうまく行うべきである。」

ほとんどのHaskell関数はたかだか数行であるべきで、
巨大なデータ型（これはまた避けるべきである）に対するcase式だけは
相当する大きさを必要としてよい。

コードは簡潔（ただしややこしくしない）で、可読性があり、
（予知しない変更後に）保守しやすくあるべきである。
適切な理由なしに変わった言語機能を用いない。

一つの字下げの大きさ（4または8文字）は固定でない。
`do`, `let`, `where`, `case ... of`を行末においてよい（次で改行してよい）。
残りの部分がレイアウトを崩さないことを確認せよ。
（正しくするのが難しくなったら、結局コードは読めなくなっているので、
分割する必要がある。）

悪い：
```haskell
case foo of Foo -> "Foo"
            Bar -> "Bar"
```
良い：
```haskell
case <なが〜〜〜〜い式> of
      Foo -> "Foo"
      Bar -> "Bar"
```
（case式において?）
レイアウト規則は選択肢を正しく整列させることを強いるので、
波括弧とセミコロンの記法は避ける。

コンパイラの警告に注意せよ。
型シグネチャを付与し、名前の上書き(shadowing)と使わない変数の定義を避けよ。
網羅的でないパターンと重なりのあるパターンは特に避けよ。

到達しない場合の選択肢がない場合、これは
"<モジュール名>.<関数名>"という固定の文字列を`error`に与えたもので埋めることができる。
これで（ありえない場合が発生したとき）誤りの場所を提示できる。
（このエラーメッセージに）元凶の値を`show`する手間をかけてはならない、
それはコードをデバッグするときにだけ一時的に行え。

未使用なコードやコメントアウトしたコードをファイルに残さない。
読む人はそれをどう解釈してよいかわからない。
（この辺は、不特定多数に向けた公開版の話だね）

### case式 ###

複数の等式によるパターン束縛宣言よりもcase式が望ましい。

常に上手くいくとは限らない：
```haskell
longFunctionName (Foo: _ : _) = e1
longFunctionName (Bar: _) = e2
```
良い：
```haskell
longFunctionName arg = case arg of
    Foo : _ : _ -> e1
    Bar : _ -> e2
    _ -> error "ProgrammingGuidelines.longFunctionName"
```
http://research.microsoft.com/~simonpj/papers/haskell-retrospective/
では、前者は<<宣言スタイル>>(declartion style)において使うべきと述べている。
等式は書き換え系向けに書かれたように見える。
（もちろんその順序は意味を持つが。）

しかしこの宣言スタイルがうまくあてはまるのは小さい例題のみで、
関数の名前や引数の数を変更しようとすると邪魔になる。
（それはrefactoring toolを作るヒントではないですか？
言語機能を封じ込める程の動機でしょうか？
可読性が下がる、という主張なら納得できますが。）

別の（SPJの弁によれば）エクストリーム記法は式スタイルである：

```haskell
longFunctionName = \ arg -> ...
```
しかしこのスタイルは薦めない。
できるだけ、左辺は一つでパターンマッチを使う（あずパターンも用いてよい）
ことを推奨する。

とはいえ、関数型のレコードの属性を設定する場合には、
ラムダ式を用いる式スタイルは手頃である。

Prelude関数の`const`, `flip`, `curry`, `uncurry`, セクション、
（普通のplain）部分適用を用いて容易に表せる場合は
ラムダ式を避ける。
しかし、ラムダ式を避けるためだけに補助関数を定義することもしない。

### 部分関数 ###

部分関数に対しては、（明らかでない場合）その前提条件を文書化し、
前提条件が（場合分けもしくはあらかじめ検査されて）
確かに満たされている場合にのみその部分関数が呼ばれることを確認する。
(原文、case statementだって）
特に、`head`の呼び出しは注意して行うか、
case式を用いて無くすとよりよい。

（Data.Maybeから輸入する`isJust`と`fromJust`を用いた）case式は通常
`maybe`関数を用いて避けることができる。

```haskell
maybe (error "<ModuleName>.<function>") id $ Map.lookup key map
```
一般に、失敗の場合をより陽に扱うことが求められる。
確かに、存在しないパターンや反駁不可パターン(irrefutable)は
実行時エラーの位置が詳細に報告されるが、
コードを読む際にはこれらは明らかではない。

### let式とwhere節 ###

`let`と`where`の混用と入れ子を避ける。
（私←誰？は式形式の`let`が好みである。）
補助関数を最上位で輸出せずに定義する。
輸出リストは使用していない関数の発見にも役立つ。

### コードの再利用 ###

同じ仕事を繰り返していると気付いたら、
コードの複製を避けるために一般化することを試みる。
何箇所も同じ誤りを修正するのは負けた感じがある。

### 関数適用の表記 ###

優先度の最も低い中置きの関数適用演算子`$`を用いると、多くの括弧を消去できる。
少なくとも、標準の中置き記法において、不要な括弧を除く努力をする。

```haskell
f x : g x ++ h x
```
```haskell
a == 1 && b == 1 || a == 0 && b == 0
```

末尾の巨大な引数を括弧でくくる（閉じ括弧が遠いところに現れる）よりも、
`$`を使うことを考えよ。

`f (g x)`は`f $ g x`となる。
連続的な関数適用`f (g (h x))`は
`f $ g $ h x`または`f . g $ h x`と書ける。

`f x = g $ h x`のような関数定義は`f = g . h`と短縮できる。

末尾の引数は、中置き演算子を含む式やcase式でもよいことに注意：

```haskell
map id $ c : l
```
```haskell
filter (const True) . map id $ case l of ...
```

しかし、$を用いた項は中置き式でさらに合成できないことに注意せよ。

おそらく誤り：

```haskell
f $ x ++ g $ x
```

しかし、式のスコープはレイアウト規則によっても制限される。
よって右辺に`$`を使うのは通常は安全である。

正しい：

```haskell
do f $ l
++
do g $ l
```

もちろん型には`$`は使えない。
GHCには、種`#`をとる(involve 返す?)基本関数がいくつかあるが、
これは`$`で適用できない。

最後の注意：
`$`（とその他の中置き演算子）は前後に空白文字をおく。
これはtemplate haskellとの衝突を避けるためである。

（また、ラムダ式では`\t`ではなく`\ t`と書く。）
(あ、conflictしてる)

### リスト内包表記 ###

これは「短くなめらかになる」場合にのみ用いる。
`map`, `filter`, `foldr`を用いることが望ましい。

(sweetに「クラッチがなめらか」「スムーズ」というニュアンスがあるらしいのだ。)

よくない：
```haskell
[toUpper c | c <- s]
```
こうする：
```haskell
map toUpper s
```

次の式を考える。

```haskell
[toUpper c | s <- strings, c <- s]
```

読む立場からみると、どの値がどの値に依存していて、
一時変数`s`と`c`の値が何度使われるかはっきりしない。
これに対して、次のコードはこれ以上明確にできない。

```haskell
map toUpper (concat strings)
```

(これはちょっと慣れの問題もあると思います。例が恣意的。)

高階関数を用いると、リストから別のデータ構造に容易に移行できる。
次を比較せよ。

```haskell
map (1+) list
```
```haskell
Set.map (1+) set
```

### 型 ###

型シノニムや組(tuple)よりも正式なデータ型を用いることが望ましい。
これはunpackや値の構築に手間が増えるとしても、である。
後に型クラスのインスタンスにする際に楽になる。
データ型にクラス制約を入れない。
（※言語仕様で排除されつつある）
クラス制約はそのデータを扱う関数にのみ付ける。

（ソフトウェアライフサイクルの？）長期間に渡り、
型シノニムを矛盾なく一貫性をもって利用することは困難である。
これはコンパイラにより検査されないことが原因である。
（コンパイラが提示する型は予測できない。
例：`FilePath`, `String`, `[Char]`）

データ型に構成子(variant?)が多いときは注意せよ。
（列挙型であるときは除く。）
構成子の間で共通の部分を繰り返さない。
これはコードの重複の原因となる。

悪い（引数の扱いを同様にする必要がある）：

```haskell
data Mode f p = Box f p | Diamond f p
```

よい（引数は一度扱えばよい）：

```haskell
data BoxOrDiamond = Box | Diamond
```
```haskell
data Mode f p = Mode BoxOrDiamond f p
```

未定義な結果が伝播する必要がある場合の次を比較せよ。

悪い：

```haskell
data Tuple a b = Tuple a b | Undefined
```

良い：
```haskell
data Tuple a b = Tuple a b
```
としておいて
```
Maybe (Tuple a b)
```
または他のモナド使う。

(こうするんでなくて？
```haskell
type Tuple a b = Maybe (TupleI a b)
data TupleI a b = Tuple a b
```
)

### レコード ###

（大きな）レコードにおいては、構成子の直接の利用は避け、
フィールドの順序や数は変更されうることを念頭に置く。

多相フィールドの（まれな）依存に注意する。

```haskell
data Fields a = VariantWithTwo
    { field1 :: a
    , field2 :: a }
```
値`v`の型は`field1`を設定するだけでは変更できない：
```haskell
v { field1 = f }
```
新たな値を作成する方がよい：
```haskell
VariantWithTwo { field1 = f }  -- field2は未定義のまま
```
もしくは、更新により実体化する多相な要素を用いる(?)：
```haskell
empty = VariantWithTwo { field1 = [], field2 = [] }
```
```haskell
empty { field1 = [f] }
```

同じフィールドを持つ複数の構成子がある場合、
その選択と更新に関するコードの重複を避けられることになるが、
多相型が依存するわずかな場合にはできない。

しかし、次がデータ型`Mode`と`BoxOrDiamond`の例のよい代替案とは考えにくい。
```haskell
data Mode f p =
     Box     { formula :: f,  positions :: p }
   | Diamond { formula :: f,  positions :: p }
```

### 入出力 ###

入出力およびモナドと、純粋な（`do`なしの）関数型プログラミングとを
厳密に分離することを心がける。（できればモジュールを分けることで）

悪い：
```haskell
    x <- return y
    ...
```
良い：
```haskell
    let x = y
    ...
```

Prelude.interactは使用しない。(なぜ？)
プログラムが（明らかとは限らない）評価の順序に依存しないことを確認する。
例えば、同じファイルを読みと書き両方をしない。

次は遅延入出力が原因で失敗する：
```haskell
do s <- readFile f
   writeFile f $ 'a' : s
```
読み込みが完了する前に書き込みが始まる。

### トレース ###

トレースはデバッグ目的のみで使用し、
利用者への応答としては用いない。
綺麗なコードをtrace呼び出しでごちゃごちゃさせてはいけない。

### 輸入 ###

`Char`, `List`, `Maybe`, `Monad`などのような標準ライブラリは
（haddockがそれを見つけられるように）
階層的モジュール名により輸入する。
(i.e. the base packageが読めない)

```haskell
import Data.List
import Control.Monad
import System.Environment
```

`Set`と`Map`のライブラリは`qualified`で輸入する。

```haskell
import qualified Data.Set as Set
import qualified Data.Map as Map
```

### GHC拡張とクラス ###

可能な限り拡張は用いない。
またクラスも注意して用いる。これは、すぐにリストと文字列のように
インスタンスに重なりを持たせたくなるからである。(?)
すると多引数型クラス(multi-parameter type classes, MTPC)と
関数的依存(functional dependencies FD)が必要になり、
これは決定不能で時には矛盾するインスタンスを招き、
（SPJによると）「荒野に放り出される」。

他言語のスタイル
----------------

OCamlスタイル
http://www.cs.caltech.edu/~cs20/a/style.html

おわりに
--------

ガイドラインにかかわらず、
（形式的証明の支援なしに）「正しいコード」を書くことは未だに大きな課題である。
このガイドラインに従う動機付けとして、
"C++ Coding Standard"の"C++"を"Haskell"に置き換えた要点を考える。

よい点：

* プログラマが任意のコードに入っていけて、何が起きているか指摘できる
* 新しい人が素早く必要な情報を把握できる (get someone up to speed http://www.gabastyle.com/english/office/office30.html へー！)
* Haskell初心者が個人的にスタイルを作り出しそれを死守することなく済ませられる
* Haskell初心者が、これまで何度も繰り返されてきた轍を踏むことをなくす
* 一貫性のある環境では誤りが起きにくい
* プログラマは共通の敵を持つ :-) (意味不明)

悪い点：

* 標準はたいていHaskellを理解していない人により作られるためくだらないことがある (は？)
* 標準はたいてい自分がしていることではないのでくだらない (?)
* 標準は生産性を下げる (?)
* 標準は人々が一貫性を持つならば不要である
* 標準は構造を強要しすぎる
* 人々は結局標準を無視する

(ある程度合意のとれたガイドラインではなくて、誰かが個人的な見解を書いただけかこれ？
クオリティ微妙だぞ。)