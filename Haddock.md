Haddockユーザガイド（抜粋）
===========================

(ライセンス条項に翻訳に関する記述がない。all rights reservedなので原則禁止、なのかな。)  
(documentという動詞に説明するという訳を思い付いた。)

1章 はじめに
------------

HaddockはHaskellソースコードの注釈から文書を自動生成するツールである。
Haddockは次の目標を念頭に設計されている。

* APIを文書化する場合、
  文書と実際のインタフェースまたはAPIの実装とを近づけておくことが望ましい。
  可能ならば同じファイルにすると、
  両者の間で同期がとれなくなること危険を減らすことができる。
  そのためHaddockは項目（関数、型、クラス）に対する文書を
  ソースコードのその要素の隣に書けるようにした。
* ソースコードそのものだけから取り出せるAPIの有益な情報が豊富にある。
  それは型、輸出されている関数、データ型やクラスの定義、などである。
  よってHaddockは素のHaskell 98モジュールの集合から文書を生成し、
  その文書はモジュールを用いるプログラマが利用できるインタフェースの詳細を含む。
* ソースコード中の文書化注釈は、ソースコードそのものの編集中に目に優しくあるべきである。
  つまり、プログラミングを邪魔しないように、
  また文書化注釈の記述も容易であるべきである。
  文書作成が容易であるほど、プログラマはそうしてくれる。
  そのためHaddockは注釈に軽量なマークアップを用いる。
  [IDoc](http://www.cse.unsw.edu.au/~chak/haskell/idoc/)
  からいくつかのアイデアを拝借している。
  実際、HaddockはIDocで注釈されたソースコードを解釈できる。
* 文書は実装の構造を晒すべきではない。
  別の言い方をすると、
  APIの実装者はどのようでも望むように実装の構造を自由にでき、
  利用者にその構造を全く見せることなくできるべきである。
  実践的な言葉ではいえば、
  APIが内部的に数個のHaskellモジュールからなっていても、
  インタフェースの利用者には一つのモジュールだけを公開したいことが多い。
  その一つのモジュールは単に実現モジュールの対応部分を再輸出している。  
  よってHaddockはHaskellモジュールシステムを理解し、
  インタフェースから輸出されていない項目だけでなく、
  インタフェースの内部モジュール構造も隠す。
  それでもなお文書化注釈は実装の隣に置くことができ、
  生成される文書では外部モジュールに伝播する。
* ハイパーリンクを辿り文書を移動できることは欠かせない。
  Haddockが生成する文書はそのためハイパーリンクがちりばめられる。
  全ての型とクラス名は対応する定義へのリンクであり、
  記述する文書化注釈には
  文書が生成されるときに自動的にリンクされる識別子を埋め込むことができる。
* さまざまな形式の文書が欲しい。オンラインや印刷物など。
  HaddockはバックエンドとしてHTML, DocBook, Hoogleが利用できる。
  また新たなバックエンドの追加も簡単なように設計されている。

2章 実行方法
------------

(省略)

### 特殊なソース ###

(Haskellのソースプログラムは通常の`.hs`の他に、
文芸的プログラミングを支援する`.lhs`の形式がある。
またCプリプロセッサを利用するソースがある。)

Haddockは内部的にGHCを利用するため、
特に何もしないでも
通常のものと文芸的なものの両方のHaskellソースを受け付ける。
ただし、Cプリプロセッサを使うには、
`--optghc`オプションを用いてGHCに`-cpp`オプションを渡す必要がある。

3章 文書化とマークアップ
------------------------

haddockはHaskellソースファイルにある文書化注釈を解釈し、
それを生成する文書に送る。
注釈を付けるかどうかは完全に任意である。
注釈がなければ、Haddockは単に
処理する各モジュールが輸出する
型シグネチャ、データ型宣言、クラス宣言を含む文書を生成する。

### トップレベル定義の文書化 ###

文書化注釈の最も単純な例は、
トップレベル定義（関数の型シグネチャ、型宣言、クラス宣言）に対する文書である。
例えば、ソースファイルが次の型シグネチャを持つとする。

```haskell
square :: Int -> Int
square x = x * x
```

すると、これは次のように説明を付けられる。

```haskell
-- |The 'square' function squares an integer.
square :: Int -> Int
square x = x * x
```

`-- |`の構文で文書化注釈を開始する。
これはソースファイルで次に現れる宣言に適用される。
注釈が単なるHaskellのコメントであることに注意せよ。
これはHaskellコンパイラからは無視される。
文書化注釈に続く宣言は必ず次のいずれかである。

* トップレベル関数の型シグネチャ
* `data`型宣言
* `newtype`宣言
* `type`宣言
* `class`宣言

注釈に続く宣言がこれらと異なる種類のものである場合、
これはおそらくHaddockに無視される。

文書を宣言の後に書きたいという人もいる。
Haddockではこれも可能である。

```haskell
square :: Int -> Int
-- ^The 'square' function squares an integer.
square x = x * x
```

HaddockはHaskellの型システムを内蔵していないことに注意せよ。
関数に対して型シグネチャを書かないと、
Haddockはその型を知ることができないので、
それは文書には含まれなくなる。
(使っていてhaddockにない関数の正体はこれか！)

文書化注釈は複数行に渡ることもできる。
ソースファイルでコメントで無い行が現れるまで注釈が続くとみなされる。

例：
```haskell
-- |The 'square' function squares an integer.
-- It takes one argument, of type 'Int'.
square :: Int -> Int
square x = x * x
```

文書化注釈はHaskellの入れ子形式のコメントに入れることもできる。
注釈が複数行になる場合にはこれが便利である。
```haskell
{-|
  The 'square' function squares an integer.
  It takes one argument, of type 'Int'.
-}
square :: Int -> Int
square x = x * x
```

### 宣言の内部に対する説明 ###

宣言全体を説明することに加えて、
宣言の内部を個々に説明したい場合がある。

#### クラスメソッド ####

クラスメソッドはトップレベル型シグネチャと同様の方法で説明を付けられる。
マークアップは`-- |`と`-- ^`のどちらも使える。

```haskell
class C a where
   -- | This is the documentation for the ’f’ method
   f :: a -> Int
   -- | This is the documentation for the ’g’ method
   g :: Int -> a
```

#### 構成子とレコードのフィールド ####

構成子は次のように説明を付けられる。

```haskell
data T a b
  -- | This is the documentation for the 'C1' constructor
  = C1 a b
  -- | This is the documentation for the 'C2' constructor
  | C2 a b
```

または次のようにする。

```haskell
data T a b
  = C1 a b -- ^ This is the documentation for the 'C1' constructor
  | C2 a b -- ^ This is the documentation for the 'C2' constructor
```

レコードのフィールドは以下のいずれかの形式で説明を付けられる。

```haskell
data R a b =
  C { -- | This is the documentation for the 'a' field
      a :: a,
      -- | This is the documentation for the 'b' field
      b :: b
    }

data R a b =
  C { a :: a -- ^ This is the documentation for the 'a' field
    , b :: b -- ^ This is the documentation for the 'b' field
    }
```

別のレイアウト形式も全般にHaddockは受け付ける。
例えば、上のレコードフィールドの並びにおいて、
文書化コメントはコンマの前後どちらに現れてもよい。

#### 関数の引数 ####

関数の個々の引数は次のようにして説明を付けられる。

```haskell
f :: Int -- ^ The 'Int' argument
  -> Float -- ^ The 'Float' argument
  -> IO () -- ^ The return value
```

### モジュールの記述 ###

モジュールはモジュールヘッダの前に文書化注釈を含むことができる。
Haddockはこの注釈をモジュールそのものの全体的な説明と解釈し、
モジュールに対する文書のDescriptionの節に置く。
例を示す。

```haskell
-- | This is the description for module "Foo"
module Foo where
...
```

### 文書構造の制御 ###

Haddockが生成するインタフェースの文書は
モジュールが実際に輸出している項目に対するものだけが並ぶ。
モジュールに対する文書は、モジュールが輸出する全ての項目を含む。
項目が他のモジュールから再輸出されているものでも同様に扱う。
唯一の例外は、Haddockが再輸出している項目の宣言を発見できない場合で、
これはおそらく現在処理しているモジュール群にその項目がないことにより起きる。

しかし、Haddockにとって輸出リストは、
単に文書に含めるべき項目の指定する以上の意味がある。
生成する文書に項目を並べる順序もこれで指定する。
これにより、プログラマは好きな順序で、
好きなモジュール内に関数の実装を書くことができ、
それでいて輸出リストにより関数が文書化される順序を指定できる。
実際、多くのプログラマは既にこれをしている。
輸出リストはしばしばad-hocなインタフェース文書のようなものとして使われる。
見出しをつけて、
型シグネチャと宣言をコメントした関数の一群があるものとして。
(ここ無理に訳さなくてもいいかな。)

輸出リストの正しい位置に注釈を入れることで、
文書に見出しや小見出しを挿入できる。
例を示す。

```haskell
module Foo (
  -- * Classes
  C(..),
  -- * Types
  -- ** A data type
  T,
  -- ** A record
  R,
  -- * Some functions
  f, g
  ) where
```
見出しは`-- *`, `-- **`などの構文で加えられる。
ここで`*`の数が見出しのレベル
（節、小節、小小節など）を表す。

節見出しを使うと、
Haddockはモジュール文書の先頭に目次を生成する。

各行の先頭にコンマを置く別スタイルにも対応している。例：

```haskell
module Foo (
  -- * Classes
  , C(..)
  -- * Types
  -- ** A data type
  , T
  -- ** A record
  , R
  -- * Some functions
  , f
  , g
  ) where
```
(一番先頭のコンマは大丈夫なん？)

#### モジュール全体の再輸出 ####

Haskellでは、モジュール名を輸出リストに並べることで
モジュール全体
（あるいは少なくとも、指定したモジュールから輸入した、
現在のスコープにあるあらゆるもの）を再輸出することができる。

```haskell
module A (
  module B,
  module C
 ) where
```

このモジュールに対してHaddockが生成する文書はどのように見えるだろうか？
それはモジュールBとCをどのように輸入したかに依存する。
`hiding`修飾なしに完全に輸入している場合、
文書はBとCの文書へのクロスリファレンスだけを含む。
しかし、モジュールが完全に再輸出されていない場合、例えばこのような：

```haskell
module A (
  module B,
  module C
 ) where

import B hiding (f)
import C (a, b)
```
HaddockはBとCから再輸出された項目の集合が
明示的に輸出リストにあるかのように振る舞う。
（注：
これはversion 0.2の段階では完全には実装されていない。
現状では、Haddockは常にクロスリファレンスを挿入する。）

この規則の例外は、輸出モジュールが`hide`属性付きで宣言された場合(3.7節)で、
このときモジュールはクロスリファレンスされず、
再輸出したモジュールにその内容が展開される。

#### 輸出リストの省略 ####

モジュールに輸出リストがない場合、Haddockはどのように文書を生成するか？
輸出リストが省略された場合、例えば
```haskell
module Foo where
```
という場合、
このモジュールのトップレベルで定義された全ての項目が輸出リストにあることと同等なので、
Haddockも同様にこれを扱う。
さらに、生成される文書はモジュール内の項目の順序を保存する。
この特別な場合には、モジュール本体は節見出しを持つ事ができる。
（通常、つまり輸出リストがある場合はこれはHaddockに無視される。）

### 文書を名前で参照する ###

どのHaskell定義にも割り付けられない説明を含めたい場合がある。
それを行う方法がふたつある。

* 輸出リストに直接文書を含めることができる。例：
```haskell
module Foo (
   -- * 節見出し

   -- | Haskellの特定の項目に割り付けられない説明
   ...
 ) where
```

* 説明が長く、輸出リストに埋め込むと膨れあがって構造が不明瞭になる場合、
  説明文書に名前を付けてモジュール本体の外に置くことができる。
  これはそのための文書化注釈の構文`-- $`により達成される。

```haskell
module Foo (
   -- * 節見出し

   -- $doc
   ...
 ) where

-- $doc
-- 名前$docで参照できる長い説明のかたまりをここに置く
```
  説明のかたまりに名前を付ける。
  名前は`-- $`の直後にあるアルファベットと数字文字の並びである。
  輸出リストにある同じ名前によりこれが参照できる。
  (参照と被参照の構文が同じなの？)

### ハイパーリンクと再輸出項目 ###

（よろしくやってくれるみたいだからこの項目は読む必要がない）

Haddockが生成文書の中に型を書くとき、
その型にある全ての型構成子とクラス名を対応する定義にハイパーリンクする。
しかし、型構成子やクラスはそれを再輸出するモジュールが複数ある場合がある。
よって複数のモジュールの文書にその型やクラスの定義が含まれうる。
（これは現在のモジュールも可能性の一つになる！）
ではどれにリンクすればよいか？

例を見よう。
次のように定義されたモジュールA,B,Cがあるとする。
```haskell
module A (T) where
data T a = C a

module B (f) where
import A
f :: T Int -> Int
f (C i) = i

module C (T, f) where
import A
import B
```
モジュールAはデータ型Tを輸出する。
モジュールBはAを輸入し、関数fを輸出し、これは型Tを参照している。
また、TとfはモジュールCから再輸出されている。

Haddockには各項目の出身モジュールという概念がある。
これは、その項目に関する文書を見つけるために
モジュール設計者が最もユーザを導きたいモジュールである。
(?)
よって、Haddockは項目へのリンクが出身モジュールを指すようにする。
一つの例外は項目が現在のモジュールからも輸出されている場合である。
Haddockは可能ならば局所リンクを作成する。

項目に対してその出身モジュールはどう決定されるか？
Haddockは次の規則を用いる。

* モジュールAとBがともにその項目を輸出しており、
  モジュールAが（直接または間接に）モジュールBを輸入している場合、
  Bが選ばれる。
* `hide`属性のあるモジュールは出身には選ばれない。
* 選ぶモジュールが他にない場合に限り、出身の属性がないモジュールが選ばれる。

複数のモジュールがこの基準にあてはまる場合、一つがランダムに選ばれる。
(わざと乱数なのか、説明したくない行き当たりばったりなやり方なだけか?)
この基準にあてはまるモジュールがない場合（候補が全て`hide`の場合）、
Haddockは出身モジュールを持たない項目を参照するたびに警告を発する。

上の例では、Tの出身にはモジュールAが選ばれる。
これがTを輸出する他のモジュールを輸入しないからである。
よって、モジュールBのfの型からのリンクはA.Tを指す。
しかしCもまたTとfを輸出しており、
よってCのfの型からのリンクは局所的にC.Tを指す。

### モジュールの属性 ###

Haddockがモジュールの文書を生成する方法に影響を与える属性を
各モジュールに指定することができる。
この属性はモジュール先頭の`{-# OPTIONS_HADDOCK ...   #-}`プラグマで指定する。
モジュール記述の前でも後でもよい。
例を示す。

```haskell
{-# OPTIONS_HADDOCK hide, prune, ignore-exports #-}

-- |モジュール説明
module A where
...
```

現在Haddockが理解できる属性は以下である。
(md+が使いたい、もしくはhtmltagを入れたい)

* `hide`
  生成する文書からこのモジュールを省略する。
  ただしモジュールにある定義と文書はこれらの定義を再輸出するモジュールに伝播する。
* `prune`
  文書化注釈を持たない定義を生成する文書から省略する。
* `ignore-exports`
  輸出リストを無視する。
  モジュールが輸出リストを持たないかのように文書を生成する。
  すなわち全てのトップレベル宣言が輸出され、節見出しがモジュール本体に入れられる。
* `not-home`
  現在のモジュールはそれが輸出する各項目の出身モジュールとみなさないことを指示する。
  ただし、他にその項目を輸出するモジュールがない場合を除く。
  詳細は3.6節を見よ。

### マークアップ ###

Haddockは文書化注釈の中の文字による特定の指示を理解する。
これは文書をどのように表示するかを指定する。
指示（マークアップ）は単純で覚えやすいように設計されたASCII文字で、
プログラマが文書化注釈を編集する際に、重い注釈を扱わなくて済む。

#### 段落 ####

1行以上の空行は文書化注釈の段落を分ける。

#### 特殊文字 ####

以下の文字は文書化注釈の中で特別な意味を持つ：
`/`, `'`, `` ` ``, `"`, `@`, `<`
これら特殊文字をその文字として挿入したい場合、
バックスラッシュ`\`を前に置く。

さらに、文字`>`は行頭では特別な意味を持つ。
文字`*`, `-`は段落の先頭で特別な意味を持つ。
これらの文字も`\`によりエスケープできる。

#### 文字参照 ####

HaskellソースファイルはUnicode文字集合の任意の文字を含むことができるが、
これらの文字をバイト列にエンコードする方法はシステムにより異なるため、
ポータビリティがあるのはASCII文字に限定したソースファイルのみである。
文字リテラルと文字列リテラルでその他の文字を指定するには
Haskellの文字エスケープを使う。
文書化注釈においてそれらの文字を使うために、
HaddockはSGML形式の数字による`&# D ;`と`&#x H ;`の形の文字参照に対応している。
ここでDやHはそれぞれUnicode(ISO 10646)のコードポジションを表す
10進数と16進数である。
例えば、`&#x3BB;`, `&#x3bb;` `&#955;`は全て小文字のラムダを表す。

#### コードブロック ####

コードブロックの表示は段落を`@...@`で囲むか、
段落の各行を`>`で開始する（これをしばしば「鳥の足跡」と呼ぶ）。
例を示す：
```haskell
-- | This documentation includes two blocks of code:
--
-- @
-- f x = x + x
-- @
--
-- > g x = x * 42
```
コードブロックの2つの形式には重要な違いが一つある。
鳥の足跡形式では、`>`の右にある文字は文字通りに解釈されるのに対して、
`@...@`形式はコードブロック内のマークアップを通常通りに解釈する。

#### リンク付き識別子 ####

Haskellの型、クラス、構成子、関数を表す識別子を参照するには、
シングルクオートで囲む。

```haskell
-- | This module defines the type 'T'.
```

現在のモジュールのスコープに項目`T`が存在すれば、
文書中の参照から`T`の定義へハイパーリンクする。
（もちろん、出力形式がハイパーリンクを扱えることが必要である。
印刷形式では、定義のページ番号参照を代わりに入れるべきだろう。）

現在のモジュールのスコープにない項目を参照することもできる。
それには項目の完全修飾名を用いる。

```haskell
-- | The identifier 'M.T' is not in scope
```

`M.T`がスコープにない場合、
Haddockは単にモジュールMから輸出された項目Tへのリンクを生成する。
（MやM.Tが存在するか否かの検査はしない。）

文書作成者を楽にするために、
クオート付きの識別子はHaskellの識別子として構文的に正しいものだけが解釈される。
これは例えば、
アポストロフィとして用いるシングルクオートをエスケープする必要が通常はないことを意味する。

```haskell
-- | I don't have to escape my apostrophes; great, isn't it?
```

他のシステムとの互換性のため、代替マークアップ構文`` `T' ``も受け付ける。
（注：厳密には`` ` ``の文字は左クオートではなく低アクセント記号なので、
これを第一のマークアップには選ばなかった。）

#### 強調文字と等幅文字 ####

文字列を`/.../`で囲むことで強調される。
等幅文字（タイプライタ体）は`@...@`で囲むことで指示する。
等幅指定の内部でのみ有効な他のマークアップがある(?)：
例えば、`@'f' a b@`はコード片の中の識別子fにハイパーリンクを付ける。
(なんかおかしいな。強調の中では他の機能が止まるけど、等幅では止まらないということ？)

#### モジュールへのリンク ####

モジュールへのリンクはモジュール名をダブルクオートで囲むことで行える。
```haskell
-- | This is a reference to the "Foo" module.
```

#### 箇条書き ####

箇条書きは`*`または`-`で段落を始めることで表す。
箇条書き段落の並びは生成文書では一続きの箇条書きとして表示される。
例を示す：
```haskell
-- | This is a bulleted list:
--
--     * first item
--
--     * second item
```

番号付き箇条書きも同様で、ただし段落を`(n)`または`n.`で始める。
ここでnは任意の整数である。例を示す。
```haskell
-- | This is an enumerated list:
--
--     (1) first item
--
--     2. second item
```

#### 定義リスト ####

定義リストは次のように書く。
```haskell
-- | This is a definition list:
--
--   [@foo@] The description of @foo@.
--
--   [@bar@] The description of @bar@.
```
これは次のように出力される。(HTML入れられないのでだいぶ異なる)

*`foo`* The description of `foo`.  
*`bar`* The description of `bar`.  

各段落の前に角括弧で囲んだ「定義項目」を置く。
定義リストの段落の開始以外の場所では角括弧は特殊文字ではない。
つまり、段落が`[`で始まるなら、それは定義リスト段落の開始が推測され、
次に`]`が現れたら定義項目が終わる。
定義項目の中で、他のマークアップ記号は自由に利用できる。

#### URL ####

URLを文書化コメントに入れるには三角括弧`<...>`で囲む。
出力形式が対応していれば、URLはハイパーリンクとして表示される。
(これ標準の方法だね)

#### アンカー ####

文書の特定の項目と対応しない箇所にリンクできると便利なことがある。
そのために、文書化コメントにアンカーを入れることができる。
構文は`#label#`で、ここでlabelはアンカーの名前である。
アンカーは生成文書には表示されない。

アンカーへのリンクを作るには、構文`module#label`を用いる。
ここでmoduleはアンカーを含むモジュールの名前で、
labelはアンカーの名前である。
モジュールは局所である必要はなく、
インタフェースから輸入したものでもよい。
(自分の中でリンクしたいときも、モジュールになっていないといけないということかしら。)
